Pro code:

Cryptography:

def generate_key() -> bytes:
"""Return a new Fernet key (bytes)."""
return Fernet.generate_key()
def encrypt_message(message: str, key: bytes) -> bytes:
"""Encrypt UTF-8 message -> ciphertext bytes."""
f = Fernet(key)
return f.encrypt(message.encode('utf-8'))
def decrypt_message(cipher_bytes: bytes, key: bytes) -> str:
"""Decrypt ciphertext bytes -> message string."""
f = Fernet(key)
return f.decrypt(cipher_bytes).decode('utf-8â€™)

Steganography:

def _bytes_to_bitlist(data: bytes) -> list:
bits = []
for b in data:
for bit in format(b, '08b'):
bits.append(int(bit))
return bits
def _bitlist_to_bytes(bits: list) -> bytes:
b = bytearray()
for i in range(0, len(bits), 8):
byte = bits[i:i+8]
if len(byte) < 8:
break
b.append(int(''.join(map(str, byte)), 2))
return bytes(b)
def capacity_bytes_from_image_bytes(image_bytes: bytes) -> int:
"""Return how many payload BYTES can be stored in this image after header."""
img = Image.open(io.BytesIO(image_bytes)).convert('RGB')
w, h = img.size
pixel_count = w * h
total_bits = pixel_count * 3
usable_bits = total_bits - 32 # reserve 32 bits for header
return usable_bits // 8

Encoding Part:

def encode_image(cover_image_bytes: bytes, data_bytes: bytes) -> bytes:
"""
Embed data_bytes into cover_image_bytes (PNG/JPEG).
Stores a 4-byte big-endian header for ciphertext length.
Returns PNG bytes of stego image.
"""
img = Image.open(io.BytesIO(cover_image_bytes)).convert('RGB')
arr = np.array(img)
flat = arr.flatten()
header = struct.pack('>I', len(data_bytes))
payload = header + data_bytes
bits = _bytes_to_bitlist(payload)
if len(bits) > flat.size:
raise ValueError("Data too large for this image. Use a larger image or shorter 
message.")
# Correction: use 254 instead of ~1 to avoid "out of bounds" error.
flat[:len(bits)] = (flat[:len(bits)] & 254) | np.array(bits, dtype=np.uint8)
stego_arr = flat.reshape(arr.shape)
stego_img = Image.fromarray(stego_arr.astype('uint8'), 'RGB')
out = io.BytesIO()
stego_img.save(out, format='PNG')
return out.getvalue()

Decoding Part:

def decode_image(stego_image_bytes: bytes) -> bytes:
"""
Extract payload bytes (with header) from stego image.
Returns ciphertext bytes (without header).
"""
img = Image.open(io.BytesIO(stego_image_bytes)).convert('RGB')
arr = np.array(img)
flat = arr.flatten()
header_bits = (flat[:32] & 1).tolist()
header_val = int(''.join(map(str, header_bits)), 2)
msg_len = header_val
total_bits_needed = 32 + msg_len * 8
if total_bits_needed > flat.size:
raise ValueError("Image has insufficient capacity or is corrupted.")
body_bits = (flat[32:total_bits_needed] & 1).tolist()
full_bits = header_bits + body_bits
full_bytes = _bitlist_to_bytes(full_bits)
return full_bytes[4:] # remove header

Image quality Check(PSNR Value):

def compute_psnr(cover_image_bytes: bytes, stego_image_bytes: bytes) -> float:
"""Compute PSNR between two images (bytes)."""
a = Image.open(io.BytesIO(cover_image_bytes)).convert('RGB')
b = Image.open(io.BytesIO(stego_image_bytes)).convert('RGB')
arr_a = np.array(a).astype(np.float64)
arr_b = np.array(b).astype(np.float64)
if arr_a.shape != arr_b.shape:
raise ValueError("Images must have the same dimensions for PSNR")
mse = np.mean((arr_a - arr_b) ** 2)
if mse == 0:
return float('inf')
psnr = 20 * math.log10(255.0 / math.sqrt(mse))
return psnr